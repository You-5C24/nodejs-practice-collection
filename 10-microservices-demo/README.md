# 微服务通信演示 (Microservices Demo)

一个简单的微服务架构演示，用于学习微服务通信和协作模式。

## 📖 学习目标

- **微服务架构：** 微服务的概念和设计原则
- **进程间通信：** HTTP、消息队列、RPC
- **服务发现：** 服务注册和发现机制
- **负载均衡：** 请求分发策略
- **容错机制：** 服务降级和熔断
- **API 网关：** 统一入口和路由

## 🎯 功能特性

### 1. 服务拆分
- 用户服务（User Service）
- 订单服务（Order Service）
- 多个独立的微服务

### 2. 通信方式
- HTTP REST API 调用
- 消息队列异步通信
- gRPC 高性能调用

### 3. 服务治理
- 服务注册和发现
- 健康检查
- 负载均衡
- 熔断降级

## 🚀 安装和使用

```bash
# 安装依赖
npm install

# 启动所有服务
npm start

# 或分别启动服务
node services/service-a/index.js
node services/service-b/index.js
```

## 🏗️ 架构设计

```
┌─────────────────┐
│   API Gateway   │
└────────┬────────┘
         │
    ┌────┴────┐
    │         │
┌───▼────┐ ┌──▼──────┐
│Service │ │Service  │
│   A    │ │    B    │
└────────┘ └─────────┘
```

## 💡 实现要点

1. 每个服务独立运行在不同端口
2. 实现服务间 HTTP 调用
3. 使用消息队列解耦服务
4. 实现健康检查端点
5. 处理服务调用失败
6. 实现简单的 API 网关

## 📚 相关知识点

- 微服务架构原理
- RESTful API 设计
- 消息队列（RabbitMQ、Redis）
- 服务注册中心（Consul、Etcd）
- 负载均衡算法
- 分布式系统基础

## 🔗 扩展方向

- 实现服务配置中心
- 添加分布式追踪
- 实现分布式日志
- 添加服务监控
- 实现熔断器模式
- 添加限流功能
- 实现服务网格
- 容器化部署（Docker）

## 📡 服务端点

### Service A (端口 3001)
```
GET  /health        - 健康检查
GET  /api/users     - 获取用户列表
POST /api/users     - 创建用户
```

### Service B (端口 3002)
```
GET  /health        - 健康检查
GET  /api/orders    - 获取订单列表
POST /api/orders    - 创建订单
```

## 🔧 通信模式

### 1. 同步调用（HTTP）
- 直接的 REST API 调用
- 适合实时性要求高的场景
- 服务间有直接依赖

### 2. 异步通信（消息队列）
- 使用消息队列传递消息
- 解耦服务依赖
- 适合非实时场景

### 3. 事件驱动
- 发布-订阅模式
- 事件溯源
- 最终一致性

## ⚠️ 注意事项

- 服务拆分要合理
- 避免过度设计
- 注意数据一致性
- 处理网络分区
- 监控和日志很重要
- 部署和运维复杂度增加

## 🎓 学习路径

1. **基础概念** - 理解微服务原理
2. **服务通信** - 掌握通信方式
3. **服务治理** - 学习服务管理
4. **部署运维** - 了解容器化和编排
5. **最佳实践** - 学习设计模式

